Notes:

Stack grows downward

Familiarize with (PC, BP, SP, and the instruction register IR)

Implementation:

While loop that fetches next instruction from "text" segment
    (3 ints per instruction), decrements (PC-3), and does rest of instructions

Must follow what Appendix A says to finest point:
    The PM/0 instruction set includes LIT, OPR, LOD,
    STO, CAL, INC, JMP, JPC and SYS instructions. 

Run on Eustis:
    gcc -Wall flag
    Run on Eustis server corrects. Adhere strictly to ANSI C (C11 is recommended).
    Example commands:
    # Compile and run on Eustis
    gcc - O2 - Wall - std = c11 -o vm vm . c
    ./ vm input . txt

Reading input & output:
    must read a single input file specified on the command line (see Section 2). 
    Must not prompt for fileName

    Must output following Appendix B format:
    Display values of each PC, BP, SP after each instructions & display contents of stack sep. by "|" bars

Required DOCU:
    Include required header comment in vm.c source file (Section 6.1)
    Get a 0 otherwise

CMD line Params:
    text file containing the P-machine program to execute.
        Consisting of 3 lines:
            (OP, L, M) sep. by whitespace -> No comments or extra fields
    Must not prompt for fileName
        if the argument count is incorrect, print an
        error and exit. Input and output formats are shown in Appendix B.

     Your program must automaticall split each line into OP , L and M tokens 
     and store them into the correct PAS indexes.

    our program should read the entire file and store each triple in the process
    address space starting from address 499 and moving downward (see Section 3):
        1st instruction field placed @ 499 → OP, 498 → L, 497. Then cont. until EOF

Output Format:

    When executing SYS 0 1 you must print the top of the stack to standard output and then pop it.

    When executing SYS 0 2 you must prompt the user to enter an integer exactly as shown in
    the sample output (“Please Enter an Integer: ”) and push the integer onto the stack.

    The SYS 0 3 instruction halts the program and should be printed as the last instruction executed

    See (Appendix B for example exact formatting)


P-Machine Review:
    PAS = static array of 500 (All entries = 0)

    PAS contains 2 segments:
        "text": stored at top of PAS, growing downward
        "stack": begins below text, grows downward as values are pushed

    After reading first 3 values from input file: 
        Set PC to 499 prior to first fetch
        Set SP to @ of last M word loaded (lowest @ in "text" segment)
        Set BP = SP - 1

Registers: (End of Page 3 - Beginning of 4 if Review Needed)

Instruction Format:
    OP: Operands for instruction to execute
    L: level for instructions that access variables in other AR's
    M: Depends of the opCode, it could be anything

Fetch-Execute Cycle:
    The VM needs 3 values per each 3 variables taken from input file, so PC will also decrement by 3 to make space for next instruction

    So, until a SYS 0 3 (To end) is encountered, the following will occur repeatedly
        IR.OP ← PAS[PC]
        IR.L ← PAS[PC-1]
        IR.M ← PAS[PC-2]
        PC ← PC - 3

    Execute Cyrcle:
        Perform based on opCode
        Appendix a

*NOTE*: Pushing values onto stack, decreases SP and popping increases SP 

AR & Base Function:
    Procedures create AR's on  stack.
    Each AR has (SL), (DL), and (RA), and its local vars.

    The (CAL) instructions uses the (L) to determine depth of static chain to traverse when linking to procedures scope

    A helper function base(bp,L) can be used to find (BP) of AR (L) levels from current AR

    /* Find base L levels down from the current activation record */
        int base ( int BP , int L ) {
            int arb = BP ; // activation record base
            while ( L > 0) {
                arb = pas [ arb ]; // follow static link
                L - -;
            }
            return arb ;
        }

What's provided: 
    Only HW1.pdf and 1 test file in Appendix B. 
    Graded will have test cases, so you can talk with TA then if you run into erros

Submission Instructions:
    Submit WebCourses, test on Eustis
    
    Progam Name: vm.c (compliled executivale to be vm)
    cmd: Accepts only the input file as solo argument
    Header commend: Place box at top of vm.c file

    /*
    Assignment :
    vm . c - Implement a P - machine virtual machine

    Authors : < Your Name ( s ) Here >

    Language : C ( only )

    To Compile :
    gcc - O2 - Wall - std = c11 -o vm vm . c

    To Execute ( on Eustis ) :
    ./ vm input . txt

    where :
    input . txt is the name of the file containing PM /0 instructions ;
    each line has three integers ( OP L M )

    Notes :
    - Implements the PM /0 virtual machine described in the homework
    instructions .
    - No dynamic memory allocation or pointer arithmetic .
    - Does not implement any VM instruction using a separate function .
    - Runs on Eustis .

    Class : COP 3402 - Systems Software - Fall 2025

    Instructor : Dr . Jie Lin

    Due Date : Friday , September 12 th , 2025
    */

    Comments: 
        Place comments on major code blocks an dedge cases in src code (Well commented earns extra credit)

    *Only Static memory is to be used*

    Max of 3 functions: Main, Base, Print -> 0% if more than 3

    No instruction functions: main loop should implement the fetch-execute cycle directly

What to submit: 
    Source code
    Team contribution Sheet (signed)
    AI disclosure Form with signature

    If you used AI: A separate markdown file describing your AI usage.
    If you did not use AI: Only the signed disclosure form is needed.

Submission Guidelines:
    program should not write to any files. All output must go to standard output exactly as specified
    Do not modify the PM/0 instruction set or input format

Grading: (graded based on both functionality and compliance with the specification)
    -100 points: Program does not compile on Eustis or cannot be built via the provided
    commands.

    • Immediate Zero: Plagiarism, changing the instruction set, using dynamic memory
    or pointer references, implementing instructions as separate functions, omitting the
    required header comment, more than three functions defined (only main, base, and
    one print function are allowed), or source is not in C.

    • 10 points: Program compiles successfully and runs.

    • 25 points: Program produces meaningful output for some instructions before crashing
    or looping infinitely.

    • 5 points: Accepts exactly one argument and prints output to the console or command
    line (no file output or saving).

    • 5 points: Required header comment present (with author names and compile/run
    instructions) in vm.c; builds on Eustis using gcc.

    • 5 points: Fetch cycle implemented correctly (correctly updates PC and IR).

    • 5 points: Well-commented source code.

    • 10 points: All OPR operations implemented correctly.

    • 10 points: SYS 0 1 and SYS 0 2 implemented correctly.

    • 10 points: Load and store instructions (LOD, STO) implemented correctly.

    • 10 points: Call and return instructions (CAL, RTN) implemented correctly.

    • 5 points: Follows formatting guidelines (output matches sample) and source code is named vm.c

Instruction Set Architecture (ISA):  (See Table 2 for OPR sub-operations)
    PM/0 supports nine opcodes.
    Tables below summarize each opcode along with a brief description and pseudocode.

Sample Inputs and Outputs: (Page 11 - 14)



    







