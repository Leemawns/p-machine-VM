/*
    Assignment :
    vm . c - Implement a P - machine virtual machine

    Authors : < Leonardo & Eric>

    Language : C ( only )

    To Compile :
    gcc - O2 - Wall - std = c11 -o vm vm . c

    To Execute ( on Eustis ) :
    ./ vm input . txt

    where :
    input . txt is the name of the file containing PM /0 instructions ;
    each line has three integers ( OP L M )

    Notes :
    - Implements the PM /0 virtual machine described in the homework
    instructions .
    - No dynamic memory allocation or pointer arithmetic .
    - Does not implement any VM instruction using a separate function .
    - Runs on Eustis .

    Class : COP 3402 - Systems Software - Fall 2025

    Instructor : Dr . Jie Lin

    Due Date : Friday , September 12 th , 2025
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CODETOP 499

typedef struct {
    int op; // Opcode
    int L;  // Call depth 
    int M;  // Modifier
} InstructionRegister;

int PAS[500] = {0};

int PC = 0;
int BP = 0;
int SP = 0;

InstructionRegister IR;

void printState(int op, int L, int M, int lastMIndex);
int base(int BP, int L);

int main(int argc, char * argv[]) {

    if (argc != 2) {
        printf("File not found\n");
        return 1;
    }

    FILE * filePtr = fopen(argv[1], "r");
    if (filePtr == NULL) {
        printf("File not read\n");
        return 1;
    }

    int op, l, m;
    int topIndex = 499;    // start at top of PAS array
    int lastMIndex = 499;  // track lowest index used

    while (fscanf(filePtr, "%d %d %d", &op, &l, &m) == 3) {
        PAS[topIndex]     = op;
        PAS[topIndex - 1] = l;
        PAS[topIndex - 2] = m;
        topIndex -= 3;
        if (topIndex + 1 < lastMIndex) {
            lastMIndex = topIndex + 1;
        }
    }
    fclose(filePtr);

    PC = 499;
    SP = lastMIndex;
    BP = SP - 1;
    IR.op = IR.L = IR.M = 0;

    printf("\tL \tM \tPC \tBP \tSP \tstack\n");
    printf("Initial values: \t%d \t%d \t%d\n", PC, BP, SP);

    int halt = 0;

    while (!halt) {
        /* FETCH */
        IR.op = PAS[PC];
        IR.L  = PAS[PC - 1];
        IR.M  = PAS[PC - 2];
        PC -= 3;

        /* EXECUTE */
        switch (IR.op) {
            case 1: // LIT
                SP--;
                PAS[SP] = IR.M;
                break;

            case 2: // OPR
                switch (IR.M) {
                    case 0: // RTN
                        SP = BP + 1;
                        BP = PAS[SP - 2];
                        PC = PAS[SP - 3];
                        break;
                    case 1: // ADD
                        PAS[SP+1] = PAS[SP+1] + PAS[SP];
                        SP++;
                        break;
                    case 2: // SUB
                        PAS[SP+1] = PAS[SP+1] - PAS[SP];
                        SP++;
                        break;
                    case 3: // MUL
                        PAS[SP+1] = PAS[SP+1] * PAS[SP];
                        SP++;
                        break;
                    case 4: // DIV
                        PAS[SP+1] = PAS[SP+1] / PAS[SP];
                        SP++;
                        break;
                    case 5: // EQL
                        PAS[SP+1] = PAS[SP+1] == PAS[SP];
                        SP++;
                        break;
                    case 6: // NEQ
                        PAS[SP+1] = PAS[SP+1] != PAS[SP];
                        SP++;
                        break;
                    case 7: // LSS
                        PAS[SP+1] = PAS[SP+1] < PAS[SP];
                        SP++;
                        break;
                    case 8: // LEQ
                        PAS[SP+1] = PAS[SP+1] <= PAS[SP];
                        SP++;
                        break;
                    case 9: // GTR
                        PAS[SP+1] = PAS[SP+1] > PAS[SP];
                        SP++;
                        break;
                    case 10: // GEQ
                        PAS[SP+1] = PAS[SP+1] >= PAS[SP];
                        SP++;
                        break;
                    default:
                        halt = 1;
                        break;
                }
                break;

            case 3: // LOD
                SP--;
                PAS[SP] = PAS[base(BP, IR.L) - IR.M];
                break;

            case 4: // STO
                PAS[base(BP, IR.L) - IR.M] = PAS[SP];
                SP++;
                break;

            case 5: // CAL
                PAS[SP - 1] = base(BP, IR.L);
                PAS[SP - 2] = BP;
                PAS[SP - 3] = PC;
                BP = SP - 1;
                PC = CODETOP - IR.M;
                break;

            case 6: // INC
                SP -= IR.M;
                break;

            case 7: // JMP
                PC = CODETOP - IR.M;
                break;

            case 8: // JPC
                if (PAS[SP] == 0) {
                    PC = CODETOP - IR.M;
                }
                SP++;
                break;

            case 9: // SYS
                if (IR.M == 1) {
                    printf("Output result is: %d\n", PAS[SP]);
                    SP++;
                } else if (IR.M == 2) {
                    int input;
                    printf("Please Enter an Integer: ");
                    scanf("%d", &input);
                    SP--;
                    PAS[SP] = input;
                } else if (IR.M == 3) {
                    halt = 1;
                }
                break;

            default:
                halt = 1;
                break;
        }

        printState(IR.op, IR.L, IR.M, lastMIndex);
    }

    return 0;
}

/* Find base L levels down from the current activation record */
int base (int BP, int L) {
    int arb = BP;
    while (L > 0) {
        arb = PAS[arb]; // follow static link
        L--;
    }
    return arb;
}

/* Print the machine state in required format */
void printState(int op, int L, int M, int lastMIndex) {

    if (op == 2){
        switch(M) {
            case 0: 
                printf("RTN "); 
                break;
            case 1: 
                printf("ADD ");
                break;
            case 2: 
                printf("SUB ");
                break;
            case 3: 
                printf("MUL ");
                break;
            case 4: 
                printf("DIV ");
                break;
            case 5: 
                printf("EQL ");
                break;
            case 6: 
                printf("NEQ ");
                break;
            case 7: 
                printf("LSS ");
                break;
            case 8:
                printf("LEQ ");
                break;
            case 9:
                printf("GTR ");
                break;
            case 10:
                printf("GEQ ");
                break;
            default:
                printf("OPR ");
        }
    } else {
        switch (op) {
            case 1:  
                printf("LIT "); 
                break;
            case 3:  
                printf("LOD "); 
                break;
            case 4:  
                printf("STO "); 
                break;
            case 5:  
                printf("CAL "); 
                break;
            case 6:  
                printf("INC "); 
                break;
            case 7:  
                printf("JMP "); 
                break;
            case 8:  
                printf("JPC "); 
                break;
            case 9:  
                printf("SYS "); 
                break;
            default: 
                printf("??? "); 
                break;
        }
    }

    printf("\t%d \t%d \t%d \t%d \t%d\t", L, M, PC, BP, SP);

    int mainBP = lastMIndex - 1;
    if(BP == mainBP){
        for (int i = lastMIndex - 1; i >= SP; i--)
            printf("%-2d ", PAS[i]);
        printf("\n");
        return;
    }

    if(SP <= BP - 3){
        for(int i  = lastMIndex - 1; i >= BP + 1; i--)
            printf("%-2d ", PAS[i]);
        
        printf("| %d %d %d ", PAS[BP], PAS[BP - 1], PAS[BP - 2]);
            // PAS[BP] is the static linker
            // PAS[BP - 1] is the dynamic linker
            // PAS[BP - 2] is the return address
            // PAS[BP - 3] is an extra slot.
        for(int i = BP - 3; i >= SP; i--)
            printf("%-2d ", PAS[i]);
        printf("\n");
    } else {
        for(int i = lastMIndex - 1; i >= SP; i--)
            printf("%-2d ", PAS[i]);
        printf("\n");
    }
}
